<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Rationale</title>
<link rel="stylesheet" href="../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Histogram">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Histogram">
<link rel="prev" href="benchmarks.html" title="Benchmarks">
<link rel="next" href="concepts.html" title="Concepts">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../boost.png"></td>
<td align="center"><a href="../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="benchmarks.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="concepts.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="histogram.rationale"></a><a class="link" href="rationale.html" title="Rationale">Rationale</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="rationale.html#histogram.rationale.philosophy_and_principles">Philosophy
      and principles</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.structure">Structure</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.histogram_host">Histogram host class</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.axis_types">Axis types</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.storage_types">Storage types</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.uoflow">Under- and overflow bins</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.variance">Variance estimates</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.weights">Support of weighted fills</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.python_support">Python support</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.serialization">Serialization</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.comparison_to_boost_accumulators">Comparison
      to Boost.Accumulators</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.philosophy_and_principles"></a><a class="link" href="rationale.html#histogram.rationale.philosophy_and_principles" title="Philosophy and principles">Philosophy
      and principles</a>
</h3></div></div></div>
<p>
        This library was written based on a decade of experience collected in working
        with big data, more precisely in the field of particle physics and astroparticle
        physics. The design is guided by advice from people like Bjarne Stroustrup,
        Scott Meyers, Herb Sutter, and Andrei Alexandrescu, and Chandler Carruth.
        I also like the <a href="https://www.python.org/dev/peps/pep-0020" target="_top">Zen
        of Python</a> (also applies to other languages). I also borrowed ideas
        from the <a href="https://eigen.tuxfamily.org/" target="_top">Eigen library</a>.
      </p>
<p>
        Design goals of the library:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Provide a simple and convenient default behavior for the casual user,
            yet allow a maximum of customization for the power user. Follow the "Don't
            pay for what you don't use" principle. Features that you don't use
            should not affect your performance negatively.
          </li>
<li class="listitem">
            Provide the same interface for one-dimensional and multi-dimensional
            histograms. This makes the interface easier to learn, and makes it easier
            to move a project from one-dimensional to multi-dimensional analysis.
            This sounds obvious, but other libraries don't do that.
          </li>
<li class="listitem">
            Hide the details of how the bin counters work. Other implementations,
            notably those in the <a href="https://root.cern.ch" target="_top">ROOT framework</a>
            expose this, which forces the user to make a choice which is potentially
            dangerous. At best, the choice is merely inefficient. In the worst case,
            it can lead to information loss in form of overflowing or capped counters.
          </li>
<li class="listitem">
            STL compatibility. If the histogram is compatible with STL algorithms,
            many tasks are one-liners. It should also feel familiar to users of
            <a href="../../../libs/accumulators/index.html" target="_top">Boost.Accumulators</a>.
            That's why values are filled with <code class="computeroutput"><span class="keyword">operator</span><span class="special">()</span></code>.
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.structure"></a><a class="link" href="rationale.html#histogram.rationale.structure" title="Structure">Structure</a>
</h3></div></div></div>
<p>
        The library consists of three orthogonal components:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <a class="link" href="rationale.html#histogram.rationale.histogram_host" title="Histogram host class">histogram host class</a>:
            The histogram host class defines the public user interface and holds
            axis objects (one for each dimension) and a storage object. The user
            can chose whether axis objects are stored in a static tuple or a dynamic
            vector.
          </li>
<li class="listitem">
            <a class="link" href="rationale.html#histogram.rationale.axis_types" title="Axis types">axis types</a>: Defines
            how input values are mapped to bins. Several axis types are provided
            which implement different specializations. Users can make their own axis
            types following the axis concept and use them with the library.
          </li>
<li class="listitem">
            <a class="link" href="rationale.html#histogram.rationale.storage_types" title="Storage types">storage types</a>:
            Manages a collection of bin counters. The requirements for a storage
            differ from those of an STL container, it needs to follow the storage
            concept. Two implementations are provided.
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.histogram_host"></a><a class="link" href="rationale.html#histogram.rationale.histogram_host" title="Histogram host class">Histogram host class</a>
</h3></div></div></div>
<p>
        Histograms store axis objects and a storage object. A one-dimensional histogram
        has one axis, a multi-dimensional histogram has several. Each axis maps a
        value from an input tuple onto an index. The histogram host class combines
        these indices into a global index that is used to address bin counter in
        the storage object.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          To understand the need for multi-dimensional histograms, think of point
          coordinates. If all points that you consider lie on a line, you need only
          one value to describe the point. If all points lie in a plane, you need
          two values to describe the position. Three values are needed for a point
          in space. A histogram puts a discrete grid over the line, the plane or
          the space, and counts how many points lie in each cell of the grid. To
          reflect a point distribution on a line, a 1d-histogram is sufficient. To
          do the same in 3d-space, one needs a 3d-histogram.
        </p></td></tr>
</table></div>
<p>
        This library supports different axis types, so that the user can customize
        how the mapping is done exactly, see <a class="link" href="rationale.html#histogram.rationale.axis_types" title="Axis types">axis
        types</a>. Users can furthermore chose between two ways of storing axis
        types in the histogram.
      </p>
<p>
        When the histogram host class is configured to store axis types in a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">tuple</span></code>,
        we obtain a static histogram. The number and types of the axes are known
        at compile-time. Axis access is done with compile-time indices. A static
        histogram is always faster (see <a class="link" href="benchmarks.html" title="Benchmarks">benchmark</a>),
        because of type conversions and run-time polymorphism are not needed, and
        because the compiler can inline more code. Furthermore, user errors are caught
        at compile-time rather than run-time.
      </p>
<p>
        The static histogram has many advantages, but cannot be used when the axis
        configuration is only known at run-time. This is the case, for example, when
        a histogram is created in Python. Therefore, axis types can also be stored
        in a generic <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">histogram</span><span class="special">::</span><span class="identifier">axis</span><span class="special">::</span><span class="identifier">any</span></code> type, which in turn can be put in a
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>. When the histogram host class is
        configured to storage axis types like this, we obtain a dynamic histogram.
        The dynamic histogram is a single type that can store an arbitrary number
        and permutations of axes types. The axis configuration can be varied arbitrarily
        at runtime. There is an additional run-time cost involved whenever an axis
        is queried to enable the polymorphic behavior of the generic <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">histogram</span><span class="special">::</span><span class="identifier">axis</span><span class="special">::</span><span class="identifier">any</span></code> type.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.axis_types"></a><a class="link" href="rationale.html#histogram.rationale.axis_types" title="Axis types">Axis types</a>
</h3></div></div></div>
<p>
        An axis defines which range of input values is mapped to which bin. The logic
        is encapsulated in an axis type. Users can create their own axis classes
        and use them with the library, by providing a class compatible with the
        <a class="link" href="concepts.html#histogram.concepts.axis" title="Axis type">axis concept</a>. The library
        comes with five builtin types, which implement different specializations.
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/histogram/axis/regular.html" title="Class template regular">boost::histogram::axis::regular</a></code>
            sorts real numbers into bins with equal width.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/histogram/axis/variable.html" title="Class template variable">boost::histogram::axis::variable</a></code>
            sorts real numbers into bins with varying width.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/histogram/axis/circular.html" title="Class template circular">boost::histogram::axis::circular</a></code>
            is a specialization of a regular axis for angles and similar values defined
            on a closed circle.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/histogram/axis/integer.html" title="Class template integer">boost::histogram::axis::integer</a></code>
            is a specialization of a regular axis for a range of integers with unit
            bin width.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/histogram/axis/category.html" title="Class template category">boost::histogram::axis::category</a></code>
            is a one-on-one mapping of a set of unique values onto bins. This can
            be used to count labels, like "red", "green", "blue".
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.storage_types"></a><a class="link" href="rationale.html#histogram.rationale.storage_types" title="Storage types">Storage types</a>
</h3></div></div></div>
<p>
        A storage type stores the actual bin counters. It uses a one-dimensional
        index for lookup, computed by the histogram host from the indices generated
        from all its axes. The storage needs to know nothing about axes. Users can
        integrate their own storage classes with the library, by providing a class
        compatible with the <a class="link" href="concepts.html#histogram.concepts.storage" title="Storage type">storage concept</a>.
      </p>
<p>
        The buildin storage types are optimised for fast look-up of the random-access
        variety and use dense (aka contiguous) storage in memory. Bin lookup is often
        happening in a tight loop. <code class="computeroutput"><a class="link" href="../boost/histogram/array_storage.html" title="Class template array_storage">boost::histogram::array_storage</a></code>
        implements a simple storage based on a heap-allocated array of a static counter
        type. That could be the end of story, but there are some issues with this
        approach. It is not convenient, because the user has to decide what type
        to use to hold the bin counts and it is not an obvious choice. An integer
        type needs to be large enough to avoid counter overflow, but only a fraction
        of the bits are used if it is too large. Using an integral type that is too
        large is a waste of memory. This is still a concern today since the performance
        of modern CPUs depends on effective utilization of the CPU cache, which is
        small. Using floating point numbers instead of integers is also dangerous.
        They don't overflow, but cap the bin count when the bits in the mantissa
        are used up.
      </p>
<p>
        The standard storage used in the library is <code class="computeroutput"><a class="link" href="../boost/histogram/adaptive_storage.html" title="Class template adaptive_storage">boost::histogram::adaptive_storage</a></code>.
        It solves these issues with a dynamic counter type management, based on the
        following insight. The <a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality" target="_top">curse
        of dimensionality</a> makes the total number of bins grow very fast as
        the dimension of the histogram grows. However, having many bins also reduces
        the number of counts per bin, since the input values are spread over many
        more bins now.
      </p>
<p>
        We therefore start with a minimum amount of memory per bin counter by using
        the smallest integer type to hold a count. If the bin counter is about to
        overflow, we switch to the next larger integer type. We start with 1 byte
        per bin counter and then double the size as needed, until 8 byte per bin
        are reached. The following images illustrate this progression for a storage
        of 3 bin counters. A new memory block is always allocated for all counters,
        when the first one of them hits its capacity limit.
      </p>
<p>
        <span class="inlinemediaobject"><object type="image/svg+xml" data="../../storage_3_uint8.svg" width="65" height="23"></object></span>
      </p>
<p>
        <span class="inlinemediaobject"><object type="image/svg+xml" data="../../storage_3_uint16.svg" width="129" height="23"></object></span>
      </p>
<p>
        <span class="inlinemediaobject"><object type="image/svg+xml" data="../../storage_3_uint32.svg" width="256" height="23"></object></span>
      </p>
<p>
        <span class="inlinemediaobject"><object type="image/svg+xml" data="../../storage_3_uint64.svg" width="511" height="23"></object></span>
      </p>
<p>
        When even that is not enough, we switch to the <a href="../../../libs/multiprecision/index.html" target="_top">Boost.Multiprecision</a>
        type <code class="computeroutput"><span class="identifier">cpp_int</span></code>, whose capacity
        is limited only by available memory. The following image is not to scale:
      </p>
<p>
        <span class="inlinemediaobject"><object type="image/svg+xml" data="../../storage_3_cpp_int.svg" width="511" height="23"></object></span>
      </p>
<p>
        This approach is not only memory conserving, but also allows us to give the
        strong guarantee that bin counters cannot overflow.
      </p>
<p>
        And now comes the best part: this approach is even faster in the multi-dimensional
        case despite the run-time overheads of handling the counter type dynamically.
        The benchmarks show that gains from better cache usage outweigh the run-time
        overheads of dynamic dispatching to the right bin counter type and the additional
        allocation costs. Doubling the size of the bin counters each time helps,
        too, because then allocations happen only O(logN) times for N bin increments.
      </p>
<p>
        In a sense, <code class="computeroutput"><a class="link" href="../boost/histogram/adaptive_storage.html" title="Class template adaptive_storage">adaptive_storage</a></code>
        is the opposite of a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>,
        which keeps the size of the stored type constant, but grows to hold a larger
        number of elements. Here, the number of elements remains the same, but the
        storage grows to hold a uniform collection of larger and larger elements.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.uoflow"></a><a class="link" href="rationale.html#histogram.rationale.uoflow" title="Under- and overflow bins">Under- and overflow bins</a>
</h3></div></div></div>
<p>
        Axis instances by default add extra bins that count values which fall below
        or above the range covered by the axis (for those types where that makes
        sense). These extra bins are called under- and overflow bins, respectively.
        The extra bins can be turned off individually for each axis to conserve memory,
        but it is generally recommended to have them. The extra bins do not interfere
        with normal bin counting. On an axis with <code class="computeroutput"><span class="identifier">n</span></code>
        bins, the first bin has the index <code class="computeroutput"><span class="number">0</span></code>,
        the last bin <code class="computeroutput"><span class="identifier">n</span><span class="special">-</span><span class="number">1</span></code>, while the under- and overflow bins are accessible
        at the indices <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>
        and <code class="computeroutput"><span class="identifier">n</span></code>, respectively.
      </p>
<p>
        Under- and overflow bins are useful in one-dimensional histograms, and nearly
        essential in multi-dimensional histograms. Here are the advantages:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            No loss: The total sum over all bin counts is strictly equal to the number
            of times the histogram was filled. Even NaN values are counted, they
            are put in the overflow-bin by convention.
          </li>
<li class="listitem">
            Diagnosis: Unexpected extreme values show up in the extra bins, which
            otherwise may be overlooked.
          </li>
<li class="listitem">
            Ability to reduce histograms: In multi-dimensional histograms, an out-of-range
            value along one axis may be paired with an in-range value along another
            axis. If under- and overflow bins are missing, such a value pair is lost
            completely. If you apply a <code class="computeroutput"><span class="identifier">reduce</span></code>
            operation on a histogram, which removes somes axes by summing all counts
            along that dimension, this would lead to distortions of the histogram
            along the remaining axes. When under- and overflow bins are present,
            the <code class="computeroutput"><span class="identifier">reduce</span></code> operation
            always produces a sub-histogram identical to one obtained if it was filled
            from scratch with the original data.
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.variance"></a><a class="link" href="rationale.html#histogram.rationale.variance" title="Variance estimates">Variance estimates</a>
</h3></div></div></div>
<p>
        Once a histogram is filled, the bin counter can be accessed with the <code class="computeroutput"><span class="identifier">at</span><span class="special">(...)</span></code>
        method. The standard counter type has a <code class="computeroutput"><span class="identifier">value</span><span class="special">()</span></code> method to return the count <span class="emphasis"><em>k</em></span>.
        It also offers a <code class="computeroutput"><span class="identifier">variance</span><span class="special">()</span></code> method, which returns an estimate <span class="emphasis"><em>v</em></span>
        of the <a href="https://en.wikipedia.org/wiki/Variance" target="_top">variance</a>
        of that count.
      </p>
<p>
        If the input values for the histogram come from a <a href="https://en.wikipedia.org/wiki/Stochastic_process" target="_top">stochastic
        process</a>, the variance provides useful additional information. Examples
        for a stochastic process are a physics experiment or a random person filling
        out a questionaire<a href="#ftn.histogram.rationale.variance.f0" class="footnote" name="histogram.rationale.variance.f0"><sup class="footnote">[3]</sup></a>. The variance <span class="emphasis"><em>v</em></span> is the square of the <a href="https://en.wikipedia.org/wiki/Standard_deviation" target="_top">standard deviation</a>.
        The standard deviation is a number that tells us how much we can expect the
        observed value to fluctuate if we or someone else would repeat our experiment
        with new random input.
      </p>
<p>
        Variance estimates are useful in many ways:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Error bars: Drawing an <a href="https://en.wikipedia.org/wiki/Error_bar" target="_top">error
            bar</a> over the interval <span class="emphasis"><em>(k - sqrt(v), k + sqrt(v))</em></span>
            is a simple visualisation of the expected random scatter of the bin value
            <span class="emphasis"><em>k</em></span>, if the histogram was cleared and filled again
            with another independent sample of the same size (e.g. by repeating the
            physics experiment or asking more people to fill a questionaire). If
            you compare the result with a fitted model (see next item), about 2/3
            of the error bars should overlap with the model, if the model is correct.
          </li>
<li class="listitem">
            Least-squares fitting: Often you have a model of the expected number
            of counts <span class="emphasis"><em>lambda</em></span> per bin, which is a function of
            parameters with unknown values. A simple method to find good (sometimes
            the best) estimates for those parameter values is to vary them until
            the sum of squared residuals <span class="emphasis"><em>(k - lambda)^2/v</em></span> is
            minimized. This is the <a href="https://en.wikipedia.org/wiki/Least_squares" target="_top">method
            of least squares</a>, in which both the bin values <span class="emphasis"><em>k</em></span>
            and variance estimates <span class="emphasis"><em>v</em></span> enter.
          </li>
<li class="listitem">
            Pull distributions: If you have two histograms filled with the same number
            of samples and you want to know whether they are in agreement, you can
            compare the so-called pull distribution. It is formed by subtracting
            the counts and dividing by the square root of their variances <span class="emphasis"><em>(k1
            - k2)/sqrt(v1 + v2)</em></span>. If the histograms are identical, the
            pull distribution randomly scatters around zero, and about 2/3 of the
            values are in the interval <span class="emphasis"><em>[ -1, 1]</em></span>.
          </li>
</ul></div>
<p>
        Why return the variance <span class="emphasis"><em>v</em></span> and not the standard deviation
        <span class="emphasis"><em>s = sqrt(v)</em></span>? The reason is the additivity of variances.
        <a href="https://en.wikipedia.org/wiki/Variance#Properties" target="_top">Variances
        of independent samples can be added</a> like normal numbers <span class="emphasis"><em>v3
        = v1 + v2</em></span>. This is not true for standard deviations, where the
        addition law is more complex <span class="emphasis"><em>s3 = sqrt(s1^2 + s2^2)</em></span>.
        In that sense, the variance is more straight-forward to use during data processing.
        It is also more efficient for the same reason. The user can take the square-root
        at the end of the processing obtain the standard deviation as needed.
      </p>
<p>
        How is the variance estimate <span class="emphasis"><em>v</em></span> computed? If we know
        the expected number of counts <span class="emphasis"><em>lambda</em></span> per bin, we could
        compute the variance as <span class="emphasis"><em>v = lambda</em></span>, because counts in
        a histogram follow the <a href="https://en.wikipedia.org/wiki/Poisson_distribution" target="_top">Poisson
        distribution</a> <a href="#ftn.histogram.rationale.variance.f1" class="footnote" name="histogram.rationale.variance.f1"><sup class="footnote">[4]</sup></a>. After filling a histogram, we do not know the expected number
        of counts <span class="emphasis"><em>lambda</em></span> for any particular bin, but we know
        the observed count <span class="emphasis"><em>k</em></span>, which is not too far from <span class="emphasis"><em>lambda</em></span>.
        We therefore might be tempted to just replace <span class="emphasis"><em>lambda</em></span>
        with <span class="emphasis"><em>k</em></span> in the formula <span class="emphasis"><em>v = lambda = k</em></span>.
        This is in fact the so-called non-parameteric estimate for the variance based
        on the <a href="https://en.wikipedia.org/wiki/Plug-in_principle" target="_top">plug-in
        principle</a>. It is the best (and only) estimate for the variance, if
        we know nothing more about the underlying stochastic process which generated
        the inputs (or want to feign ignorance about it).
      </p>
<p>
        Now, if the number returned by the <code class="computeroutput"><span class="identifier">variance</span><span class="special">()</span></code> method is just the same as the number return
        by <code class="computeroutput"><span class="identifier">value</span><span class="special">()</span></code>
        method, why bother with adding a <code class="computeroutput"><span class="identifier">variance</span><span class="special">()</span></code> method? There is a reason, which becomes
        apparent if the histograms are filled with weights, which is discussed next.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.weights"></a><a class="link" href="rationale.html#histogram.rationale.weights" title="Support of weighted fills">Support of weighted fills</a>
</h3></div></div></div>
<p>
        A histogram sorts input values into bins and increments a bin counter if
        an input value falls into the range covered by that bin. The <code class="computeroutput"><a class="link" href="../boost/histogram/adaptive_storage.html" title="Class template adaptive_storage">standard
        storage</a></code> uses integer types to store these counts, see the <a class="link" href="rationale.html#histogram.rationale.storage_types" title="Storage types">storage section</a> how integer
        overflow is avoided. However, sometimes histograms need to be filled with
        values that have a weight <span class="emphasis"><em>w</em></span> attached to them. In this
        case, the corresponding bin counter is not increased by one, but by the passed
        weight <span class="emphasis"><em>w</em></span>.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          There are several uses for weighted increments. The main use in particle
          physics is to adapt simulated data of an experiment to real data. Simulations
          are needed to determine various corrections and efficiencies, but a simulated
          experiment is almost never a perfect replica of the real experiment. In
          addition, simulations are expensive to do. So, when deviations in a simulated
          distribution of a variable are found, one typically does not rerun the
          simulations, but assigns weights to match the simulated distribution to
          the real one.
        </p></td></tr>
</table></div>
<p>
        When the <code class="computeroutput"><a class="link" href="../boost/histogram/adaptive_storage.html" title="Class template adaptive_storage">adaptive_storage</a></code>
        is used, histograms may also be filled with weighted value tuples. The choice
        of using weighted fills can be made at run-time. If the call <code class="computeroutput"><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">weight</span><span class="special">(</span><span class="identifier">x</span><span class="special">),</span> <span class="special">...)</span></code>
        is used, two doubles per bin are stored (previous integer counts are automatically
        converted). The first double keeps track of the sum of weights. The second
        double keeps track of the sum of weights squared, which is the variance estimate
        in this case. The former is accessed with the <code class="computeroutput"><span class="identifier">value</span><span class="special">()</span></code> method of the bin counter, and the latter
        with the <code class="computeroutput"><span class="identifier">variance</span><span class="special">()</span></code>
        method.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          Why the sum of weights squared is the variance estimate can be derived
          from the <a href="https://en.wikipedia.org/wiki/Variance#Properties" target="_top">mathematical
          properties of the variance</a>. Let us say a bin is filled <span class="emphasis"><em>k1</em></span>
          times with a fixed weight <span class="emphasis"><em>w1</em></span>. The sum of weights is
          then <span class="emphasis"><em>w1 k1</em></span>. It then follows from the variance properties
          that <span class="emphasis"><em>Var(w1 k1) = w1^2 Var(k1)</em></span>. Using the reasoning
          from before, the estimated variance of <span class="emphasis"><em>k1</em></span> is <span class="emphasis"><em>k1</em></span>,
          so that <span class="emphasis"><em>Var(w1 k1) = w1^2 Var(k1) = w1^2 k1</em></span>. Variances
          of independent samples are additive. If the bin is further filled <span class="emphasis"><em>k2</em></span>
          times with weight <span class="emphasis"><em>w2</em></span>, the sum of weights is <span class="emphasis"><em>w1
          k1 + w2 k2</em></span>, with variance <span class="emphasis"><em>w1^2 k1 + w2^2 k2</em></span>.
          This also holds for <span class="emphasis"><em>k1 = k2 = 1</em></span>. Therefore, the sum
          of weights <span class="emphasis"><em>w[i]</em></span> has variance sum of <span class="emphasis"><em>w[i]^2</em></span>.
          In other words, to incrementally keep track of the variance of the sum
          of weights, we need to keep track of the sum of weights squared.
        </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.python_support"></a><a class="link" href="rationale.html#histogram.rationale.python_support" title="Python support">Python support</a>
</h3></div></div></div>
<p>
        Python is a popular scripting language in the data science community. Thus,
        the library provides Python bindings. The histogram may be used as an interface
        between a complex simulation or data-storage system written in C++ and data-analysis/plotting
        in Python. Users are able to define the histogram in Python, let it be filled
        on the C++ side (using a few lines of Boost.Python code to define the interface),
        and then get it back for further data analysis or plotting.
      </p>
<p>
        Data analysis in Python is Numpy-based, so Numpy is fully supported. Histograms
        can be filled with chunks of data in a form of Numpy arrays, which is efficient,
        and the bin counts can be retrieved as a Numpy array without copying data.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          If number of dimensions is larger than one, this implementation is faster
          than the equivalent Numpy functions (while being more flexible), see <a class="link" href="benchmarks.html" title="Benchmarks">benchmark</a>.
        </p></td></tr>
</table></div>
<p>
        The Python and C++ interface were designed to be as consistent as possible,
        while following established style for the respective C++ or Python community.
        This leads to the following stylistic changes on the Python side.
      </p>
<p>
        Properties: Getter/setter-like functions on the C++ side are wrapped in Python
        as properties. Examples: <code class="computeroutput"><span class="identifier">histogram</span><span class="special">.</span><span class="identifier">dim</span></code>,
        <code class="computeroutput"><span class="identifier">axis</span><span class="special">.</span><span class="identifier">regular</span><span class="special">.</span><span class="identifier">uoflow</span></code>. In general, a C++ function that
        takes no argument but returns a value is using the property syntax on the
        Python side.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">len</span><span class="special">(</span><span class="identifier">x</span><span class="special">)</span></code> versus
        <code class="computeroutput"><span class="identifier">x</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span></code>:
        An axis instance behaves like a container of bins in C++ and like a sequence
        of bins in Python. To get the length of a sequence in Python one uses the
        <code class="computeroutput"><span class="identifier">len</span><span class="special">(...)</span></code>
        function, while in C++ one uses the <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code> method.
      </p>
<p>
        Keyword-based parameters: the member function call <code class="computeroutput"><span class="keyword">operator</span><span class="special">()(</span><span class="identifier">weight</span><span class="special">(</span><span class="identifier">x</span><span class="special">),</span>
        <span class="special">...)</span></code> in C++ is translated into a Python
        member function call <code class="computeroutput"><span class="identifier">__call__</span><span class="special">(...,</span> <span class="identifier">weight</span><span class="special">=</span><span class="identifier">x</span><span class="special">)</span></code>.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.serialization"></a><a class="link" href="rationale.html#histogram.rationale.serialization" title="Serialization">Serialization</a>
</h3></div></div></div>
<p>
        Serialization is implemented using <a href="../../../libs/serialization/index.html" target="_top">Boost.Serialization</a>.
        Pickling in Python is implemented based on the C++ serialization code. In
        the current implementation, the pickled stream is <span class="bold"><strong>not</strong></span>
        portable between different hardware platforms, since it uses <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">archive</span><span class="special">::</span><span class="identifier">binary_archive</span></code>. It would be great to switch
        to a portable binary representation in the future, when that becomes available.
        In practice, most computing clusters and most consumer hardware are x86 compatible
        nowadays. The binary_archive is portable between such hardware platforms.
        Naturally, it is portable between operating systems, like OSX, Windows, and
        Linux.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.comparison_to_boost_accumulators"></a><a class="link" href="rationale.html#histogram.rationale.comparison_to_boost_accumulators" title="Comparison to Boost.Accumulators">Comparison
      to Boost.Accumulators</a>
</h3></div></div></div>
<p>
        Boost.Histogram has a minor overlap with <a href="../../../libs/accumulators/index.html" target="_top">Boost.Accumulators</a>,
        but the scopes are rather different. The statistical accumulators <code class="computeroutput"><span class="identifier">density</span></code> and <code class="computeroutput"><span class="identifier">weighted_density</span></code>
        in Boost.Accumulators generate one-dimensional histograms. The axis range
        and the bin widths are determined automatically from a cached sample of initial
        values. Boost.Histogram focusses on multi-dimensional data and gives the
        user full control of how the binning should be done for each dimension.
      </p>
<p>
        Automatic binning is not an option for Boost.Histogram, because it does not
        scale well to many dimensions. Because of the Curse of Dimensionality, a
        prohibitive number of samples would need to be collected.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          There is no scientific consensus on how do automatic binning in an optimal
          way, mostly because there is no consensus over the cost function (there
          are many articles with different solutions in the literature). The problem
          is not solved for one-dimensional data, and even less so for multi-dimensional
          data.
        </p></td></tr>
</table></div>
<p>
        Recommendation:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Boost.Accumulators
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
                  You have one-dimensional data of which you know nothing about,
                  and you want a histogram quickly without worrying about binning
                  details.
                </li></ul></div>
          </li>
<li class="listitem">
            Boost.Histogram
            <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; ">
<li class="listitem">
                  You have multi-dimensional data or you suspect you will switch
                  to multi-dimensional data later.
                </li>
<li class="listitem">
                  You want to customize the binning by hand, for example, to make
                  bin edges coincide with special values or to handle special properties
                  of your values, like angles defined on a circle.
                </li>
</ul></div>
          </li>
</ul></div>
</div>
<div class="footnotes">
<br><hr style="width:100; text-align:left;margin-left: 0">
<div id="ftn.histogram.rationale.variance.f0" class="footnote"><p><a href="#histogram.rationale.variance.f0" class="para"><sup class="para">[3] </sup></a>
          The choices of the person are most likely not random, but if we pick a
          random person from a group, we randomly sample from a pool of opinions
        </p></div>
<div id="ftn.histogram.rationale.variance.f1" class="footnote"><p><a href="#histogram.rationale.variance.f1" class="para"><sup class="para">[4] </sup></a>
          The Poisson distribution is correct as far as the counts <span class="emphasis"><em>k</em></span>
          themselves are of interest. If the fractions per bin <span class="emphasis"><em>p = k /
          N</em></span> are of interest, where <span class="emphasis"><em>N</em></span> is the total
          number of counts, then the correct distribution to describe the fractions
          is the <a href="https://en.wikipedia.org/wiki/Multinomial_distribution" target="_top">multinomial
          distribution</a>.
        </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016, 2017 Hans Dembinski<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="benchmarks.html"><img src="../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="concepts.html"><img src="../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
