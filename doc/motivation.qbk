[section:motivation Motivation]

Histograms are a basic tool in statistical analysis. When analysing large data sets, it is usually more convenient to work with a histogram of the input values. Histograms can compactly represent a data set of stochastic variables. If the histogram layout is chosen appropriately, any information present in the original can also be extracted from the histogram[footnote
Parameters of interest, like the center of a distribution, can be extracted from the histogram instead of the original data set; statistical models can be fitted to histograms to the same end.]; the information loss due to binning is then negligible. Processing a histogram is much faster than processing the original data, because the memory footprint of a histogram is much smaller. Next to data visualisation, this is the main reason to use histograms. In other words, a histogram is a lossy compression of statistical data.

C++ lacks a widely-used, free multi-dimensional histogram class. While it is easy to write a one-dimensional histogram, writing a general multi-dimensional histogram poses more of a challenge. If you add serialization and Python/Numpy bindings onto the wish-list, then the implementation becomes non-trivial and a well-tested library solution desirable.

The [@https://www.gnu.org/software/gsl GNU Scientific Library (GSL)] and in the [@https://root.cern.ch ROOT framework] from CERN have histogram implementations. The C implementations of the GSL are elegant, but only support one and two dimensions. The implementations are not customizable, you have to live with the trade-offs chosen by the implementors. ROOT has decade-old implementations of histograms which are not customizable and suffer from a few design flaws. It also has new better implementations in beta-stage similar to this one, but they cannot be used without the rest of ROOT, which is a huge highly non-modular library.

The histogram class template in this library has a minimalistic interface, which strives to be as elegant as the GSL implementations. In addition, it is very customizable and extensible through policy classes and in the way input values are binned. Thanks to variadic templates, the interface remains straight-forward for any number of dimensions. While being safe, customizable, and convenient, the histogram is also very performant. The static variant, which uses compile-time information wherever possible, is faster than any tested competitor.

A central design goal was to abstract away details of the internal counters. The internal counting mechanism is encapsulated in a storage policy, which can be replaced at compile-time. The default storage implements an adaptive memory managment which is safe to use, memory-efficient, and fast. The safety comes from the guarantee, that counts cannot overflow or be capped. This is a rare guarantee other libraries usually cannot give. In the standard configuration, the histogram *just works* under any circumstance. Yet, users with unusual requirements can implement their own custom storage policy or use an alternative builtin array-based storage.

[endsect]